// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: station.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStations = `-- name: CountStations :one
SELECT count(*) FROM observations_station
WHERE (CASE WHEN $1::text IS NOT NULL THEN status = $1 ELSE TRUE END)
`

func (q *Queries) CountStations(ctx context.Context, status pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countStations, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStationsWithinBBox = `-- name: CountStationsWithinBBox :one
SELECT count(*) FROM observations_station
WHERE geom && ST_MakeEnvelope($1::real, $2::real, $3::real, $4::real, 4326)
  AND (CASE WHEN $5::text IS NOT NULL THEN status = $5 ELSE TRUE END)
`

type CountStationsWithinBBoxParams struct {
	Xmin   float32     `json:"xmin"`
	Ymin   float32     `json:"ymin"`
	Xmax   float32     `json:"xmax"`
	Ymax   float32     `json:"ymax"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) CountStationsWithinBBox(ctx context.Context, arg CountStationsWithinBBoxParams) (int64, error) {
	row := q.db.QueryRow(ctx, countStationsWithinBBox,
		arg.Xmin,
		arg.Ymin,
		arg.Xmax,
		arg.Ymax,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStationsWithinRadius = `-- name: CountStationsWithinRadius :one
SELECT count(*) FROM observations_station
WHERE ST_DWithin(geom, ST_Point($1::real, $2::real, 4326), $3::real)
  AND (CASE WHEN $4::text IS NOT NULL THEN status = $4 ELSE TRUE END)
`

type CountStationsWithinRadiusParams struct {
	Cx     float32     `json:"cx"`
	Cy     float32     `json:"cy"`
	R      float32     `json:"r"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) CountStationsWithinRadius(ctx context.Context, arg CountStationsWithinRadiusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countStationsWithinRadius,
		arg.Cx,
		arg.Cy,
		arg.R,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStation = `-- name: CreateStation :one
INSERT INTO observations_station (
  name,
  lat,
  lon,
  elevation,
  date_installed,
  mo_station_id,
  sms_system_type,
  mobile_number,
  station_type,
  station_type2,
  station_url,
  status,
  logger_version,
  priority_level,
  provider_id,
  province,
  region,
  address,
  geom
) VALUES (
  $1, $17, $18, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, 
  CASE
    WHEN $18::real IS NOT NULL AND $17::real IS NOT NULL THEN ST_Point($18::real, $17::real, 4326)
    ELSE ST_GeomFromEWKT('POINT EMPTY')
  END
) RETURNING id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom
`

type CreateStationParams struct {
	Name          string        `json:"name"`
	Elevation     pgtype.Float4 `json:"elevation"`
	DateInstalled pgtype.Date   `json:"date_installed"`
	MoStationID   pgtype.Text   `json:"mo_station_id"`
	SmsSystemType pgtype.Text   `json:"sms_system_type"`
	MobileNumber  pgtype.Text   `json:"mobile_number"`
	StationType   pgtype.Text   `json:"station_type"`
	StationType2  pgtype.Text   `json:"station_type2"`
	StationUrl    pgtype.Text   `json:"station_url"`
	Status        pgtype.Text   `json:"status"`
	LoggerVersion pgtype.Text   `json:"logger_version"`
	PriorityLevel pgtype.Text   `json:"priority_level"`
	ProviderID    pgtype.Text   `json:"provider_id"`
	Province      pgtype.Text   `json:"province"`
	Region        pgtype.Text   `json:"region"`
	Address       pgtype.Text   `json:"address"`
	Lat           pgtype.Float4 `json:"lat"`
	Lon           pgtype.Float4 `json:"lon"`
}

func (q *Queries) CreateStation(ctx context.Context, arg CreateStationParams) (ObservationsStation, error) {
	row := q.db.QueryRow(ctx, createStation,
		arg.Name,
		arg.Elevation,
		arg.DateInstalled,
		arg.MoStationID,
		arg.SmsSystemType,
		arg.MobileNumber,
		arg.StationType,
		arg.StationType2,
		arg.StationUrl,
		arg.Status,
		arg.LoggerVersion,
		arg.PriorityLevel,
		arg.ProviderID,
		arg.Province,
		arg.Region,
		arg.Address,
		arg.Lat,
		arg.Lon,
	)
	var i ObservationsStation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Lat,
		&i.Lon,
		&i.Elevation,
		&i.DateInstalled,
		&i.MoStationID,
		&i.SmsSystemType,
		&i.MobileNumber,
		&i.StationType,
		&i.StationType2,
		&i.StationUrl,
		&i.Status,
		&i.LoggerVersion,
		&i.PriorityLevel,
		&i.ProviderID,
		&i.Province,
		&i.Region,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Geom,
	)
	return i, err
}

const deleteStation = `-- name: DeleteStation :exec
DELETE FROM observations_station WHERE id = $1
`

func (q *Queries) DeleteStation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteStation, id)
	return err
}

const getStation = `-- name: GetStation :one
SELECT id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom FROM observations_station
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStation(ctx context.Context, id int64) (ObservationsStation, error) {
	row := q.db.QueryRow(ctx, getStation, id)
	var i ObservationsStation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Lat,
		&i.Lon,
		&i.Elevation,
		&i.DateInstalled,
		&i.MoStationID,
		&i.SmsSystemType,
		&i.MobileNumber,
		&i.StationType,
		&i.StationType2,
		&i.StationUrl,
		&i.Status,
		&i.LoggerVersion,
		&i.PriorityLevel,
		&i.ProviderID,
		&i.Province,
		&i.Region,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Geom,
	)
	return i, err
}

const getStationByMobileNumber = `-- name: GetStationByMobileNumber :one
SELECT id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom FROM observations_station
WHERE mobile_number = $1 LIMIT 1
`

func (q *Queries) GetStationByMobileNumber(ctx context.Context, mobileNumber pgtype.Text) (ObservationsStation, error) {
	row := q.db.QueryRow(ctx, getStationByMobileNumber, mobileNumber)
	var i ObservationsStation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Lat,
		&i.Lon,
		&i.Elevation,
		&i.DateInstalled,
		&i.MoStationID,
		&i.SmsSystemType,
		&i.MobileNumber,
		&i.StationType,
		&i.StationType2,
		&i.StationUrl,
		&i.Status,
		&i.LoggerVersion,
		&i.PriorityLevel,
		&i.ProviderID,
		&i.Province,
		&i.Region,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Geom,
	)
	return i, err
}

const listStations = `-- name: ListStations :many
SELECT id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom FROM observations_station
WHERE
  (CASE WHEN $1::text IS NOT NULL THEN status = $1 ELSE TRUE END)
ORDER BY id
LIMIT $3
OFFSET $2
`

type ListStationsParams struct {
	Status pgtype.Text `json:"status"`
	Offset int32       `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) ListStations(ctx context.Context, arg ListStationsParams) ([]ObservationsStation, error) {
	rows, err := q.db.Query(ctx, listStations, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObservationsStation{}
	for rows.Next() {
		var i ObservationsStation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Elevation,
			&i.DateInstalled,
			&i.MoStationID,
			&i.SmsSystemType,
			&i.MobileNumber,
			&i.StationType,
			&i.StationType2,
			&i.StationUrl,
			&i.Status,
			&i.LoggerVersion,
			&i.PriorityLevel,
			&i.ProviderID,
			&i.Province,
			&i.Region,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsWithinBBox = `-- name: ListStationsWithinBBox :many
SELECT id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom FROM observations_station
WHERE geom && ST_MakeEnvelope($1::real, $2::real, $3::real, $4::real, 4326)
  AND (CASE WHEN $5::text IS NOT NULL THEN status = $5 ELSE TRUE END)
ORDER BY id
LIMIT $7
OFFSET $6
`

type ListStationsWithinBBoxParams struct {
	Xmin   float32     `json:"xmin"`
	Ymin   float32     `json:"ymin"`
	Xmax   float32     `json:"xmax"`
	Ymax   float32     `json:"ymax"`
	Status pgtype.Text `json:"status"`
	Offset int32       `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) ListStationsWithinBBox(ctx context.Context, arg ListStationsWithinBBoxParams) ([]ObservationsStation, error) {
	rows, err := q.db.Query(ctx, listStationsWithinBBox,
		arg.Xmin,
		arg.Ymin,
		arg.Xmax,
		arg.Ymax,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObservationsStation{}
	for rows.Next() {
		var i ObservationsStation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Elevation,
			&i.DateInstalled,
			&i.MoStationID,
			&i.SmsSystemType,
			&i.MobileNumber,
			&i.StationType,
			&i.StationType2,
			&i.StationUrl,
			&i.Status,
			&i.LoggerVersion,
			&i.PriorityLevel,
			&i.ProviderID,
			&i.Province,
			&i.Region,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsWithinRadius = `-- name: ListStationsWithinRadius :many
SELECT id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom FROM observations_station
WHERE ST_DWithin(geom, ST_Point($1::real, $2::real, 4326), $3::real)
  AND (CASE WHEN $4::text IS NOT NULL THEN status = $4 ELSE TRUE END)
ORDER BY id
LIMIT $6
OFFSET $5
`

type ListStationsWithinRadiusParams struct {
	Cx     float32     `json:"cx"`
	Cy     float32     `json:"cy"`
	R      float32     `json:"r"`
	Status pgtype.Text `json:"status"`
	Offset int32       `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) ListStationsWithinRadius(ctx context.Context, arg ListStationsWithinRadiusParams) ([]ObservationsStation, error) {
	rows, err := q.db.Query(ctx, listStationsWithinRadius,
		arg.Cx,
		arg.Cy,
		arg.R,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObservationsStation{}
	for rows.Next() {
		var i ObservationsStation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Elevation,
			&i.DateInstalled,
			&i.MoStationID,
			&i.SmsSystemType,
			&i.MobileNumber,
			&i.StationType,
			&i.StationType2,
			&i.StationUrl,
			&i.Status,
			&i.LoggerVersion,
			&i.PriorityLevel,
			&i.ProviderID,
			&i.Province,
			&i.Region,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStation = `-- name: UpdateStation :one
UPDATE observations_station
SET
  name = COALESCE($1, name),
  lat = COALESCE($2, lat),
  lon = COALESCE($3, lon),
  elevation = COALESCE($4, elevation),
  date_installed = COALESCE($5, date_installed),
  mo_station_id = COALESCE($6, mo_station_id),
  sms_system_type = COALESCE($7, sms_system_type),
  mobile_number = COALESCE($8, mobile_number),
  station_type = COALESCE($9, station_type),
  station_type2 = COALESCE($10, station_type2),
  station_url = COALESCE($11, station_url),
  status = COALESCE($12, status),
  logger_version = COALESCE($13, logger_version),
  priority_level = COALESCE($14, priority_level),
  provider_id = COALESCE($15, provider_id),
  province = COALESCE($16, province),
  region = COALESCE($17, region),
  address = COALESCE($18, address),
  geom = COALESCE(ST_POINT($3, $2, 4326), geom),
  updated_at = now()
WHERE id = $19
RETURNING id, name, lat, lon, elevation, date_installed, mo_station_id, sms_system_type, mobile_number, station_type, station_type2, station_url, status, logger_version, priority_level, provider_id, province, region, address, created_at, updated_at, deleted_at, geom
`

type UpdateStationParams struct {
	Name          pgtype.Text   `json:"name"`
	Lat           pgtype.Float4 `json:"lat"`
	Lon           pgtype.Float4 `json:"lon"`
	Elevation     pgtype.Float4 `json:"elevation"`
	DateInstalled pgtype.Date   `json:"date_installed"`
	MoStationID   pgtype.Text   `json:"mo_station_id"`
	SmsSystemType pgtype.Text   `json:"sms_system_type"`
	MobileNumber  pgtype.Text   `json:"mobile_number"`
	StationType   pgtype.Text   `json:"station_type"`
	StationType2  pgtype.Text   `json:"station_type2"`
	StationUrl    pgtype.Text   `json:"station_url"`
	Status        pgtype.Text   `json:"status"`
	LoggerVersion pgtype.Text   `json:"logger_version"`
	PriorityLevel pgtype.Text   `json:"priority_level"`
	ProviderID    pgtype.Text   `json:"provider_id"`
	Province      pgtype.Text   `json:"province"`
	Region        pgtype.Text   `json:"region"`
	Address       pgtype.Text   `json:"address"`
	ID            int64         `json:"id"`
}

func (q *Queries) UpdateStation(ctx context.Context, arg UpdateStationParams) (ObservationsStation, error) {
	row := q.db.QueryRow(ctx, updateStation,
		arg.Name,
		arg.Lat,
		arg.Lon,
		arg.Elevation,
		arg.DateInstalled,
		arg.MoStationID,
		arg.SmsSystemType,
		arg.MobileNumber,
		arg.StationType,
		arg.StationType2,
		arg.StationUrl,
		arg.Status,
		arg.LoggerVersion,
		arg.PriorityLevel,
		arg.ProviderID,
		arg.Province,
		arg.Region,
		arg.Address,
		arg.ID,
	)
	var i ObservationsStation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Lat,
		&i.Lon,
		&i.Elevation,
		&i.DateInstalled,
		&i.MoStationID,
		&i.SmsSystemType,
		&i.MobileNumber,
		&i.StationType,
		&i.StationType2,
		&i.StationUrl,
		&i.Status,
		&i.LoggerVersion,
		&i.PriorityLevel,
		&i.ProviderID,
		&i.Province,
		&i.Region,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Geom,
	)
	return i, err
}
